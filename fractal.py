import math
import random

import numpy as np

from typing import Generator

NUM_MIN = 2500  # Min. number of points generated (inclusive)
NUM_MAX = 6400  # Max. number of points generated (inclusive)


class Fractal:
    def __init__(self) -> None:
        self.name = "GeneralFractal"


    def transformation(self, pct: int, point: tuple[float, float]):
        """
        Compute coordinates of next point based on current 'point'
        and the probability distribution 'pct'.

        Note:
            This general implementation does nothing important.
            Should be overridden in class children.

        Args:
            pct (int): Probability distribution in percents (0 - 100)
            point (tuple(float, float)): Point coordinates

        Returns:
            tuple(float, float, int): Coordinates and index of transformation used
        """
        return point + (0, )


    def generate_points(self, num: int, x_start: float, y_start: float) -> list[tuple[float, float, int]]:
        """
        Generate a sequence of points of a fractal.

        Args:
            num (int): Number of points in the sequence; has to be in <NUM_MIN, NUM_MAX)
            x_start (float): X coordinate of the starting point
            y_start (float): Y coordinate of the starting point

        Returns:
            list(tuple(float, float, int)): List of coordinates and index of transformation used
        """        
        result = []
        x_next, y_next = (x_start, y_start)
        for _ in range(num):
            fortune = random.randint(0, 100)
            x_next, y_next, fn = self.transformation(fortune, (x_next, y_next))
            result.append((x_next, y_next, fn,))
        return result


    def generate(self, num: int) -> list[tuple[float, float, int]]:
        """
        Generate a list of fractal points and save them to a file.

        Args:
            num (int): Number of points

        Raises:
            ValueError: In case of invalid number of points.

        Returns:
            list[tuple[float, float, int]]: List of points and method used to generate them
        """
        # Raise an exception in case of an invalid value
        if num not in range(NUM_MIN, NUM_MAX + 1):
            # Terminate function and signal an error state
            raise ValueError(
                f"Number of points has to be in the interval <{NUM_MIN}, {NUM_MAX}>"
            )
        
        points = self.generate_points(num, 0.0, 0.0)
        filename = f"{self.name}_{num}.txt"
        with open(filename, "w") as f:
            for each_point in points:
                x, y, _ = each_point
                f.write(f"{x},{y}\n")
        return points


    def discretise(self, fractal_points: list[tuple[float, float, int]], m: int):
        """
        Generate frequency distribution of `fractal_points`.
        Save that distribution to a file.

        Args:
            fractal_points (): Fractal point as generated by generate()
            m (int): Number of bins

        Raises:
            ValueError: _description_

        Returns:
            _type_: _description_
        """
        num = len(fractal_points)
        if m not in range(num // 100, int(math.sqrt(num))):
            # Terminate function and signal an error state
            raise ValueError(f"Invalid number of bins")

        # 'm' has a correct value here
        # Find a distribution frequency of points
        x_coords, y_coords, method = zip(*fractal_points)
        result,xedges, yedges = np.histogram2d(x_coords, y_coords, bins=m, 
            density=False)

        filename = f"{self.name}_discret.txt"
        with open(filename, "w") as f:
            for row in result:
                line = ",".join([str(int(x)) for x in row])
                f.write(f"{line}\n")
        return result
